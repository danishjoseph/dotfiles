"use strict";
/*
 * Because we don't want to depend on @nx/workspace (to speed up the workspace creation)
 * we duplicate the helper functions from @nx/workspace in this file.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.output = void 0;
const chalk = require("chalk");
const os_1 = require("os");
const is_ci_1 = require("./ci/is-ci");
/**
 * Automatically disable styling applied by chalk if CI=true
 */
if ((0, is_ci_1.isCI)()) {
    chalk.level = 0;
}
class CLIOutput {
    constructor() {
        /**
         * Expose some color and other utility functions so that other parts of the codebase that need
         * more fine-grained control of message bodies are still using a centralized
         * implementation.
         */
        this.colors = {
            gray: chalk.gray,
            green: chalk.green,
            red: chalk.red,
            cyan: chalk.cyan,
            white: chalk.white,
        };
        this.bold = chalk.bold;
        this.underline = chalk.underline;
        this.dim = chalk.dim;
        this.cliName = 'NX';
    }
    /**
     * Longer dash character which forms more of a continuous line when place side to side
     * with itself, unlike the standard dash character
     */
    get VERTICAL_SEPARATOR() {
        let divider = '';
        for (let i = 0; i < process.stdout.columns - 1; i++) {
            divider += '\u2014';
        }
        return divider;
    }
    writeToStdOut(str) {
        process.stdout.write(str);
    }
    writeOutputTitle({ color, title, }) {
        this.writeToStdOut(`${this.applyCLIPrefix(color, title)}${os_1.EOL}`);
    }
    writeOptionalOutputBody(bodyLines) {
        if (!bodyLines) {
            return;
        }
        this.addNewline();
        bodyLines.forEach((bodyLine) => this.writeToStdOut(`${bodyLine}${os_1.EOL}`));
    }
    setCliName(name) {
        this.cliName = name;
    }
    applyCLIPrefix(color = 'cyan', text) {
        let cliPrefix = '';
        if (chalk[color]) {
            cliPrefix = chalk.reset.inverse.bold[color](` ${this.cliName} `);
        }
        else {
            cliPrefix = chalk.reset.inverse.bold.keyword(color)(` ${this.cliName} `);
        }
        return `${cliPrefix}  ${text}`;
    }
    addNewline() {
        this.writeToStdOut(os_1.EOL);
    }
    addVerticalSeparator(color = 'gray') {
        this.addNewline();
        this.addVerticalSeparatorWithoutNewLines(color);
        this.addNewline();
    }
    addVerticalSeparatorWithoutNewLines(color = 'gray') {
        this.writeToStdOut(`${chalk.dim[color](this.VERTICAL_SEPARATOR)}${os_1.EOL}`);
    }
    error({ title, bodyLines }) {
        this.addNewline();
        this.writeOutputTitle({
            color: 'red',
            title: chalk.red(title),
        });
        this.writeOptionalOutputBody(bodyLines);
        this.addNewline();
    }
    warn({ title, bodyLines }) {
        this.addNewline();
        this.writeOutputTitle({
            color: 'yellow',
            title: chalk.yellow(title),
        });
        this.writeOptionalOutputBody(bodyLines);
        this.addNewline();
    }
    note({ title, bodyLines }) {
        this.addNewline();
        this.writeOutputTitle({
            color: 'orange',
            title: chalk.keyword('orange')(title),
        });
        this.writeOptionalOutputBody(bodyLines);
        this.addNewline();
    }
    success({ title, bodyLines }) {
        this.addNewline();
        this.writeOutputTitle({
            color: 'green',
            title: chalk.green(title),
        });
        this.writeOptionalOutputBody(bodyLines);
        this.addNewline();
    }
    logSingleLine(message) {
        this.addNewline();
        this.writeOutputTitle({
            color: 'gray',
            title: message,
        });
        this.addNewline();
    }
    log({ title, bodyLines, color }) {
        this.addNewline();
        this.writeOutputTitle({
            color: 'cyan',
            title: color ? chalk[color](title) : title,
        });
        this.writeOptionalOutputBody(bodyLines);
        this.addNewline();
    }
}
exports.output = new CLIOutput();
