"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.determinePackageManager = exports.determineDefaultBase = exports.determineIfGitHubWillBeUsed = exports.determineNxCloud = void 0;
const ab_testing_1 = require("../utils/nx/ab-testing");
const output_1 = require("../utils/output");
const default_base_1 = require("../utils/git/default-base");
const package_manager_1 = require("../utils/package-manager");
const string_utils_1 = require("../utils/string-utils");
const enquirer = require("enquirer");
const chalk = require("chalk");
async function determineNxCloud(parsedArgs) {
    if (parsedArgs.nxCloud === undefined) {
        return nxCloudPrompt('setupCI');
    }
    else {
        return parsedArgs.nxCloud;
    }
}
exports.determineNxCloud = determineNxCloud;
async function determineIfGitHubWillBeUsed(nxCloud) {
    if (nxCloud === 'yes' || nxCloud === 'circleci') {
        const reply = await enquirer.prompt([
            {
                name: 'github',
                message: 'Will you be using GitHub as your git hosting provider?',
                type: 'autocomplete',
                choices: [{ name: 'Yes' }, { name: 'No' }],
                initial: 0,
            },
        ]);
        return reply.github === 'Yes';
    }
    return false;
}
exports.determineIfGitHubWillBeUsed = determineIfGitHubWillBeUsed;
async function nxCloudPrompt(key) {
    const { message, choices, initial, fallback, footer, hint } = ab_testing_1.messages.getPrompt(key);
    const promptConfig = {
        name: 'NxCloud',
        message,
        type: 'autocomplete',
        choices,
        initial,
    }; // meeroslav: types in enquirer are not up to date
    if (footer) {
        promptConfig.footer = () => chalk.dim(footer);
    }
    if (hint) {
        promptConfig.hint = () => chalk.dim(hint);
    }
    return enquirer.prompt([promptConfig]).then((a) => {
        if (fallback && a.NxCloud === fallback.value) {
            return nxCloudPrompt(fallback.key);
        }
        return a.NxCloud;
    });
}
async function determineDefaultBase(parsedArgs) {
    if (parsedArgs.defaultBase) {
        return Promise.resolve(parsedArgs.defaultBase);
    }
    if (parsedArgs.allPrompts) {
        return enquirer
            .prompt([
            {
                name: 'DefaultBase',
                message: `Main branch name`,
                initial: `main`,
                type: 'input',
            },
        ])
            .then((a) => {
            if (!a.DefaultBase) {
                output_1.output.error({
                    title: 'Invalid branch name',
                    bodyLines: [`Branch name cannot be empty`],
                });
                process.exit(1);
            }
            return a.DefaultBase;
        });
    }
    return Promise.resolve((0, default_base_1.deduceDefaultBase)());
}
exports.determineDefaultBase = determineDefaultBase;
async function determinePackageManager(parsedArgs) {
    const packageManager = parsedArgs.packageManager;
    if (packageManager) {
        if (package_manager_1.packageManagerList.includes(packageManager)) {
            return Promise.resolve(packageManager);
        }
        output_1.output.error({
            title: 'Invalid package manager',
            bodyLines: [
                `Package manager must be one of ${(0, string_utils_1.stringifyCollection)([
                    ...package_manager_1.packageManagerList,
                ])}`,
            ],
        });
        process.exit(1);
    }
    if (parsedArgs.allPrompts) {
        return enquirer
            .prompt([
            {
                name: 'packageManager',
                message: `Which package manager to use`,
                initial: 0,
                type: 'autocomplete',
                choices: [
                    { name: 'npm', message: 'NPM' },
                    { name: 'yarn', message: 'Yarn' },
                    { name: 'pnpm', message: 'PNPM' },
                    { name: 'bun', message: 'Bun' },
                ],
            },
        ])
            .then((a) => a.packageManager);
    }
    return Promise.resolve((0, package_manager_1.detectInvokedPackageManager)());
}
exports.determinePackageManager = determinePackageManager;
