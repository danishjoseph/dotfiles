"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.commandsObject = void 0;
const enquirer = require("enquirer");
const yargs = require("yargs");
const chalk = require("chalk");
const create_workspace_1 = require("../src/create-workspace");
const preset_1 = require("../src/utils/preset/preset");
const output_1 = require("../src/utils/output");
const nx_version_1 = require("../src/utils/nx/nx-version");
const point_to_tutorial_and_course_1 = require("../src/utils/preset/point-to-tutorial-and-course");
const decorator_1 = require("./decorator");
const get_third_party_preset_1 = require("../src/utils/preset/get-third-party-preset");
const prompts_1 = require("../src/internal-utils/prompts");
const yargs_options_1 = require("../src/internal-utils/yargs-options");
const show_nx_warning_1 = require("../src/utils/nx/show-nx-warning");
const nx_cloud_1 = require("../src/utils/nx/nx-cloud");
const ab_testing_1 = require("../src/utils/nx/ab-testing");
const error_utils_1 = require("../src/utils/error-utils");
const fs_1 = require("fs");
exports.commandsObject = yargs
    .wrap(yargs.terminalWidth())
    .parserConfiguration({
    'strip-dashed': true,
    'dot-notation': true,
})
    .command(
// this is the default and only command
'$0 [name] [options]', 'Create a new Nx workspace', (yargs) => (0, yargs_options_1.withOptions)(yargs
    .option('name', {
    describe: chalk.dim `Workspace name (e.g. org name)`,
    type: 'string',
})
    .option('preset', {
    describe: chalk.dim `Customizes the initial content of your workspace. Default presets include: [${Object.values(preset_1.Preset)
        .map((p) => `"${p}"`)
        .join(', ')}]. To build your own see https://nx.dev/extending-nx/recipes/create-preset`,
    type: 'string',
})
    .option('interactive', {
    describe: chalk.dim `Enable interactive mode with presets`,
    type: 'boolean',
    default: true,
})
    .option('workspaceType', {
    describe: chalk.dim `The type of workspace to create`,
    choices: ['integrated', 'package-based', 'standalone'],
    type: 'string',
})
    .option('appName', {
    describe: chalk.dim `The name of the app when using a monorepo with certain stacks`,
    type: 'string',
})
    .option('style', {
    describe: chalk.dim `Stylesheet type to be used with certain stacks`,
    type: 'string',
})
    .option('standaloneApi', {
    describe: chalk.dim `Use Standalone Components if generating an Angular app`,
    type: 'boolean',
    default: true,
})
    .option('routing', {
    describe: chalk.dim `Add a routing setup for an Angular app`,
    type: 'boolean',
    default: true,
})
    .option('bundler', {
    describe: chalk.dim `Bundler to be used to build the app`,
    type: 'string',
})
    .option('framework', {
    describe: chalk.dim `Framework option to be used with certain stacks`,
    type: 'string',
})
    .option('docker', {
    describe: chalk.dim `Generate a Dockerfile for the Node API`,
    type: 'boolean',
})
    .option('nextAppDir', {
    describe: chalk.dim `Enable the App Router for Next.js`,
    type: 'boolean',
})
    .option('nextSrcDir', {
    describe: chalk.dim `Generate a 'src/' directory for Next.js`,
    type: 'boolean',
})
    .option('e2eTestRunner', {
    describe: chalk.dim `Test runner to use for end to end (E2E) tests.`,
    choices: ['playwright', 'cypress', 'none'],
    type: 'string',
})
    .option('ssr', {
    describe: chalk.dim `Enable Server-Side Rendering (SSR) and Static Site Generation (SSG/Prerendering) for the Angular application`,
    type: 'boolean',
})
    .option('prefix', {
    describe: chalk.dim `Prefix to use for Angular component and directive selectors.`,
    type: 'string',
}), yargs_options_1.withNxCloud, yargs_options_1.withUseGitHub, yargs_options_1.withAllPrompts, yargs_options_1.withPackageManager, yargs_options_1.withGitOptions), async function handler(argv) {
    await main(argv).catch((error) => {
        const { version } = require('../package.json');
        output_1.output.error({
            title: `Something went wrong! v${version}`,
        });
        throw error;
    });
}, [normalizeArgsMiddleware])
    .help('help', chalk.dim `Show help`)
    .updateLocale(decorator_1.yargsDecorator)
    .version('version', chalk.dim `Show version`, nx_version_1.nxVersion);
async function main(parsedArgs) {
    output_1.output.log({
        title: `Creating your v${nx_version_1.nxVersion} workspace.`,
    });
    const workspaceInfo = await (0, create_workspace_1.createWorkspace)(parsedArgs.preset, parsedArgs);
    (0, show_nx_warning_1.showNxWarning)(parsedArgs.name);
    await (0, ab_testing_1.recordStat)({
        nxVersion: nx_version_1.nxVersion,
        command: 'create-nx-workspace',
        useCloud: parsedArgs.nxCloud !== 'skip',
        meta: [
            ab_testing_1.messages.codeOfSelectedPromptMessage('setupCI'),
            ab_testing_1.messages.codeOfSelectedPromptMessage('setupNxCloud'),
        ],
    });
    if (parsedArgs.nxCloud && workspaceInfo.nxCloudInfo) {
        (0, nx_cloud_1.printNxCloudSuccessMessage)(workspaceInfo.nxCloudInfo);
    }
    if ((0, preset_1.isKnownPreset)(parsedArgs.preset)) {
        (0, point_to_tutorial_and_course_1.pointToTutorialAndCourse)(parsedArgs.preset);
    }
    else {
        output_1.output.log({
            title: `Successfully applied preset: ${parsedArgs.preset}`,
        });
    }
}
/**
 * This function is used to normalize the arguments passed to the command.
 * It would:
 * - normalize the preset.
 * @param argv user arguments
 */
async function normalizeArgsMiddleware(argv) {
    output_1.output.log({
        title: "Let's create a new workspace [https://nx.dev/getting-started/intro]",
    });
    try {
        argv.name = await determineFolder(argv);
        if (!argv.preset || (0, preset_1.isKnownPreset)(argv.preset)) {
            argv.stack = await determineStack(argv);
            const presetOptions = await determinePresetOptions(argv);
            Object.assign(argv, presetOptions);
        }
        else {
            try {
                (0, get_third_party_preset_1.getPackageNameFromThirdPartyPreset)(argv.preset);
            }
            catch (e) {
                if (e instanceof Error) {
                    output_1.output.error({
                        title: `Could not find preset "${argv.preset}"`,
                        bodyLines: (0, error_utils_1.mapErrorToBodyLines)(e),
                    });
                }
                else {
                    console.error(e);
                }
                process.exit(1);
            }
        }
        const packageManager = await (0, prompts_1.determinePackageManager)(argv);
        const defaultBase = await (0, prompts_1.determineDefaultBase)(argv);
        if (process.env.NX_NEW_CLOUD_ONBOARDING === 'true') {
            const nxCloud = argv.skipGit === true ? 'skip' : await (0, prompts_1.determineNxCloud)(argv);
            const useGitHub = nxCloud === 'skip'
                ? undefined
                : nxCloud === 'github' ||
                    (await (0, prompts_1.determineIfGitHubWillBeUsed)(nxCloud));
            Object.assign(argv, {
                nxCloud,
                useGitHub,
                packageManager,
                defaultBase,
            });
        }
        else {
            const nxCloud = await (0, prompts_1.determineNxCloud)(argv);
            Object.assign(argv, {
                nxCloud,
                packageManager,
                defaultBase,
            });
        }
    }
    catch (e) {
        console.error(e);
        process.exit(1);
    }
}
function invariant(predicate, message) {
    if (!predicate) {
        output_1.output.error(message);
        process.exit(1);
    }
}
async function determineFolder(parsedArgs) {
    const folderName = parsedArgs._[0]
        ? parsedArgs._[0].toString()
        : parsedArgs.name;
    if (folderName)
        return folderName;
    const reply = await enquirer.prompt([
        {
            name: 'folderName',
            message: `Where would you like to create your workspace?`,
            initial: 'org',
            type: 'input',
        },
    ]);
    invariant(reply.folderName, {
        title: 'Invalid folder name',
        bodyLines: [`Folder name cannot be empty`],
    });
    invariant(!(0, fs_1.existsSync)(reply.folderName), {
        title: 'That folder is already taken',
    });
    return reply.folderName;
}
async function determineStack(parsedArgs) {
    if (parsedArgs.preset) {
        switch (parsedArgs.preset) {
            case preset_1.Preset.Angular:
            case preset_1.Preset.AngularStandalone:
            case preset_1.Preset.AngularMonorepo:
                return 'angular';
            case preset_1.Preset.React:
            case preset_1.Preset.ReactStandalone:
            case preset_1.Preset.ReactMonorepo:
            case preset_1.Preset.NextJs:
            case preset_1.Preset.NextJsStandalone:
            case preset_1.Preset.RemixStandalone:
            case preset_1.Preset.RemixMonorepo:
            case preset_1.Preset.ReactNative:
            case preset_1.Preset.Expo:
                return 'react';
            case preset_1.Preset.Vue:
            case preset_1.Preset.VueStandalone:
            case preset_1.Preset.VueMonorepo:
            case preset_1.Preset.Nuxt:
            case preset_1.Preset.NuxtStandalone:
                return 'vue';
            case preset_1.Preset.Nest:
            case preset_1.Preset.NodeStandalone:
            case preset_1.Preset.Express:
                return 'node';
            case preset_1.Preset.Apps:
            case preset_1.Preset.NPM:
            case preset_1.Preset.TS:
            case preset_1.Preset.TsStandalone:
                return 'none';
            case preset_1.Preset.WebComponents:
            default:
                return 'unknown';
        }
    }
    const { stack } = await enquirer.prompt([
        {
            name: 'stack',
            message: `Which stack do you want to use?`,
            type: 'autocomplete',
            choices: [
                {
                    name: `none`,
                    message: `None:          Configures a TypeScript/JavaScript project with minimal structure.`,
                },
                {
                    name: `react`,
                    message: `React:         Configures a React application with your framework of choice.`,
                },
                {
                    name: `vue`,
                    message: `Vue:           Configures a Vue application with your framework of choice.`,
                },
                {
                    name: `angular`,
                    message: `Angular:       Configures a Angular application with modern tooling.`,
                },
                {
                    name: `node`,
                    message: `Node:          Configures a Node API application with your framework of choice.`,
                },
            ],
        },
    ]);
    return stack;
}
async function determinePresetOptions(parsedArgs) {
    switch (parsedArgs.stack) {
        case 'none':
            return determineNoneOptions(parsedArgs);
        case 'react':
            return determineReactOptions(parsedArgs);
        case 'angular':
            return determineAngularOptions(parsedArgs);
        case 'vue':
            return determineVueOptions(parsedArgs);
        case 'node':
            return determineNodeOptions(parsedArgs);
        default:
            return parsedArgs;
    }
}
async function determineNoneOptions(parsedArgs) {
    let preset;
    let workspaceType = undefined;
    let appName = undefined;
    let js;
    if (parsedArgs.preset) {
        preset = parsedArgs.preset;
    }
    else {
        workspaceType = await determinePackageBasedOrIntegratedOrStandalone();
        if (workspaceType === 'standalone') {
            preset = preset_1.Preset.TsStandalone;
        }
        else if (workspaceType === 'integrated') {
            preset = preset_1.Preset.Apps;
        }
        else {
            preset = preset_1.Preset.NPM;
        }
    }
    if (parsedArgs.js !== undefined) {
        js = parsedArgs.js;
    }
    else if (preset === preset_1.Preset.TsStandalone) {
        // Only standalone TS preset generates a default package, so we need to provide --js and --appName options.
        appName = parsedArgs.name;
        const reply = await enquirer.prompt([
            {
                name: 'ts',
                message: `Would you like to use TypeScript with this project?`,
                type: 'autocomplete',
                choices: [
                    {
                        name: 'Yes',
                    },
                    {
                        name: 'No',
                    },
                ],
                initial: 0,
            },
        ]);
        js = reply.ts === 'No';
    }
    return { preset, js, appName };
}
async function determineReactOptions(parsedArgs) {
    let preset;
    let style = undefined;
    let appName;
    let bundler = undefined;
    let e2eTestRunner = undefined;
    let nextAppDir = false;
    let nextSrcDir = false;
    if (parsedArgs.preset && parsedArgs.preset !== preset_1.Preset.React) {
        preset = parsedArgs.preset;
        if (preset === preset_1.Preset.ReactStandalone ||
            preset === preset_1.Preset.NextJsStandalone ||
            preset === preset_1.Preset.RemixStandalone) {
            appName = parsedArgs.appName ?? parsedArgs.name;
        }
        else {
            appName = await determineAppName(parsedArgs);
        }
    }
    else {
        const framework = await determineReactFramework(parsedArgs);
        // React Native and Expo only support integrated monorepos for now.
        // TODO(jack): Add standalone support for React Native and Expo.
        const workspaceType = framework === 'react-native' || framework === 'expo'
            ? 'integrated'
            : await determineStandaloneOrMonorepo();
        if (workspaceType === 'standalone') {
            appName = parsedArgs.name;
        }
        else {
            appName = await determineAppName(parsedArgs);
        }
        if (framework === 'nextjs') {
            if (workspaceType === 'standalone') {
                preset = preset_1.Preset.NextJsStandalone;
            }
            else {
                preset = preset_1.Preset.NextJs;
            }
        }
        else if (framework === 'remix') {
            if (workspaceType === 'standalone') {
                preset = preset_1.Preset.RemixStandalone;
            }
            else {
                preset = preset_1.Preset.RemixMonorepo;
            }
        }
        else if (framework === 'react-native') {
            preset = preset_1.Preset.ReactNative;
        }
        else if (framework === 'expo') {
            preset = preset_1.Preset.Expo;
        }
        else {
            if (workspaceType === 'standalone') {
                preset = preset_1.Preset.ReactStandalone;
            }
            else {
                preset = preset_1.Preset.ReactMonorepo;
            }
        }
    }
    if (preset === preset_1.Preset.ReactStandalone || preset === preset_1.Preset.ReactMonorepo) {
        bundler = await determineReactBundler(parsedArgs);
        e2eTestRunner = await determineE2eTestRunner(parsedArgs);
    }
    else if (preset === preset_1.Preset.NextJs || preset === preset_1.Preset.NextJsStandalone) {
        nextAppDir = await determineNextAppDir(parsedArgs);
        nextSrcDir = await determineNextSrcDir(parsedArgs);
        e2eTestRunner = await determineE2eTestRunner(parsedArgs);
    }
    else if (preset === preset_1.Preset.RemixMonorepo ||
        preset === preset_1.Preset.RemixStandalone) {
        e2eTestRunner = await determineE2eTestRunner(parsedArgs);
    }
    if (parsedArgs.style) {
        style = parsedArgs.style;
    }
    else if (preset === preset_1.Preset.ReactStandalone ||
        preset === preset_1.Preset.ReactMonorepo ||
        preset === preset_1.Preset.NextJs ||
        preset === preset_1.Preset.NextJsStandalone) {
        const reply = await enquirer.prompt([
            {
                name: 'style',
                message: `Default stylesheet format`,
                initial: 0,
                type: 'autocomplete',
                choices: [
                    {
                        name: 'css',
                        message: 'CSS',
                    },
                    {
                        name: 'scss',
                        message: 'SASS(.scss)       [ https://sass-lang.com   ]',
                    },
                    {
                        name: 'less',
                        message: 'LESS              [ https://lesscss.org     ]',
                    },
                    {
                        name: 'tailwind',
                        message: 'tailwind          [ https://tailwindcss.com     ]',
                    },
                    {
                        name: 'styled-components',
                        message: 'styled-components [ https://styled-components.com            ]',
                    },
                    {
                        name: '@emotion/styled',
                        message: 'emotion           [ https://emotion.sh                       ]',
                    },
                    {
                        name: 'styled-jsx',
                        message: 'styled-jsx        [ https://www.npmjs.com/package/styled-jsx ]',
                    },
                ],
            },
        ]);
        style = reply.style;
    }
    return {
        preset,
        style,
        appName,
        bundler,
        nextAppDir,
        nextSrcDir,
        e2eTestRunner,
    };
}
async function determineVueOptions(parsedArgs) {
    let preset;
    let style = undefined;
    let appName;
    let e2eTestRunner = undefined;
    if (parsedArgs.preset && parsedArgs.preset !== preset_1.Preset.Vue) {
        preset = parsedArgs.preset;
        if (preset === preset_1.Preset.VueStandalone || preset === preset_1.Preset.NuxtStandalone) {
            appName = parsedArgs.appName ?? parsedArgs.name;
        }
        else {
            appName = await determineAppName(parsedArgs);
        }
    }
    else {
        const framework = await determineVueFramework(parsedArgs);
        const workspaceType = await determineStandaloneOrMonorepo();
        if (workspaceType === 'standalone') {
            appName = parsedArgs.appName ?? parsedArgs.name;
        }
        else {
            appName = await determineAppName(parsedArgs);
        }
        if (framework === 'nuxt') {
            if (workspaceType === 'standalone') {
                preset = preset_1.Preset.NuxtStandalone;
            }
            else {
                preset = preset_1.Preset.Nuxt;
            }
        }
        else {
            if (workspaceType === 'standalone') {
                preset = preset_1.Preset.VueStandalone;
            }
            else {
                preset = preset_1.Preset.VueMonorepo;
            }
        }
    }
    e2eTestRunner = await determineE2eTestRunner(parsedArgs);
    if (parsedArgs.style) {
        style = parsedArgs.style;
    }
    else {
        const reply = await enquirer.prompt([
            {
                name: 'style',
                message: `Default stylesheet format`,
                initial: 0,
                type: 'autocomplete',
                choices: [
                    {
                        name: 'css',
                        message: 'CSS',
                    },
                    {
                        name: 'scss',
                        message: 'SASS(.scss)       [ https://sass-lang.com   ]',
                    },
                    {
                        name: 'less',
                        message: 'LESS              [ https://lesscss.org     ]',
                    },
                    {
                        name: 'none',
                        message: 'None',
                    },
                ],
            },
        ]);
        style = reply.style;
    }
    return { preset, style, appName, e2eTestRunner };
}
async function determineAngularOptions(parsedArgs) {
    let preset;
    let style;
    let appName;
    let e2eTestRunner = undefined;
    let bundler = undefined;
    let ssr = undefined;
    const standaloneApi = parsedArgs.standaloneApi;
    const routing = parsedArgs.routing;
    const prefix = parsedArgs.prefix;
    if (prefix) {
        // https://github.com/angular/angular-cli/blob/main/packages/schematics/angular/utility/validation.ts#L11-L14
        const htmlSelectorRegex = /^[a-zA-Z][.0-9a-zA-Z]*((:?-[0-9]+)*|(:?-[a-zA-Z][.0-9a-zA-Z]*(:?-[0-9]+)*)*)$/;
        // validate whether component/directive selectors will be valid with the provided prefix
        if (!htmlSelectorRegex.test(`${prefix}-placeholder`)) {
            output_1.output.error({
                title: `Failed to create a workspace.`,
                bodyLines: [
                    `The provided "${prefix}" prefix is invalid. It must be a valid HTML selector.`,
                ],
            });
            process.exit(1);
        }
    }
    if (parsedArgs.preset && parsedArgs.preset !== preset_1.Preset.Angular) {
        preset = parsedArgs.preset;
        if (preset === preset_1.Preset.AngularStandalone) {
            appName = parsedArgs.name;
        }
        else {
            appName = await determineAppName(parsedArgs);
        }
    }
    else {
        const workspaceType = await determineStandaloneOrMonorepo();
        if (workspaceType === 'standalone') {
            preset = preset_1.Preset.AngularStandalone;
            appName = parsedArgs.name;
        }
        else {
            preset = preset_1.Preset.AngularMonorepo;
            appName = await determineAppName(parsedArgs);
        }
    }
    if (parsedArgs.bundler) {
        bundler = parsedArgs.bundler;
    }
    else {
        const reply = await enquirer.prompt([
            {
                name: 'bundler',
                message: `Which bundler would you like to use?`,
                type: 'autocomplete',
                choices: [
                    {
                        name: 'esbuild',
                        message: 'esbuild [ https://esbuild.github.io/ ]',
                    },
                    {
                        name: 'webpack',
                        message: 'Webpack [ https://webpack.js.org/ ]',
                    },
                ],
                initial: 0,
            },
        ]);
        bundler = reply.bundler;
    }
    if (parsedArgs.style) {
        style = parsedArgs.style;
    }
    else {
        const reply = await enquirer.prompt([
            {
                name: 'style',
                message: `Default stylesheet format`,
                initial: 0,
                type: 'autocomplete',
                choices: [
                    {
                        name: 'css',
                        message: 'CSS',
                    },
                    {
                        name: 'scss',
                        message: 'SASS(.scss)       [ https://sass-lang.com   ]',
                    },
                    {
                        name: 'less',
                        message: 'LESS              [ https://lesscss.org     ]',
                    },
                ],
            },
        ]);
        style = reply.style;
    }
    if (parsedArgs.ssr !== undefined) {
        ssr = parsedArgs.ssr;
    }
    else {
        const reply = await enquirer.prompt([
            {
                name: 'ssr',
                message: 'Do you want to enable Server-Side Rendering (SSR) and Static Site Generation (SSG/Prerendering)?',
                type: 'autocomplete',
                choices: [{ name: 'Yes' }, { name: 'No' }],
                initial: 1,
            },
        ]);
        ssr = reply.ssr === 'Yes';
    }
    e2eTestRunner = await determineE2eTestRunner(parsedArgs);
    return {
        preset,
        style,
        appName,
        standaloneApi,
        routing,
        e2eTestRunner,
        bundler,
        ssr,
        prefix,
    };
}
async function determineNodeOptions(parsedArgs) {
    let preset;
    let appName;
    let framework;
    let docker;
    if (parsedArgs.preset) {
        preset = parsedArgs.preset;
        if (preset === preset_1.Preset.Nest ||
            preset === preset_1.Preset.Express ||
            preset === preset_1.Preset.NodeMonorepo) {
            appName = await determineAppName(parsedArgs);
        }
        else {
            appName = parsedArgs.name;
        }
        if (preset === preset_1.Preset.NodeStandalone || preset === preset_1.Preset.NodeMonorepo) {
            framework = await determineNodeFramework(parsedArgs);
        }
        else {
            framework = 'none';
        }
    }
    else {
        framework = await determineNodeFramework(parsedArgs);
        const workspaceType = await determineStandaloneOrMonorepo();
        if (workspaceType === 'standalone') {
            preset = preset_1.Preset.NodeStandalone;
            appName = parsedArgs.name;
        }
        else {
            preset = preset_1.Preset.NodeMonorepo;
            appName = await determineAppName(parsedArgs);
        }
    }
    if (parsedArgs.docker !== undefined) {
        docker = parsedArgs.docker;
    }
    else {
        const reply = await enquirer.prompt([
            {
                name: 'docker',
                message: 'Would you like to generate a Dockerfile? [https://docs.docker.com/]',
                type: 'autocomplete',
                choices: [
                    {
                        name: 'Yes',
                        hint: 'I want to generate a Dockerfile',
                    },
                    {
                        name: 'No',
                    },
                ],
                initial: 1,
            },
        ]);
        docker = reply.docker === 'Yes';
    }
    return {
        preset,
        appName,
        framework,
        docker,
    };
}
async function determinePackageBasedOrIntegratedOrStandalone() {
    const { workspaceType } = await enquirer.prompt([
        {
            type: 'autocomplete',
            name: 'workspaceType',
            message: `Package-based monorepo, integrated monorepo, or standalone project?`,
            initial: 0,
            choices: [
                {
                    name: 'package-based',
                    message: 'Package-based Monorepo:     Nx makes it fast, but lets you run things your way.',
                },
                {
                    name: 'integrated',
                    message: 'Integrated Monorepo:        Nx creates a monorepo that contains multiple projects.',
                },
                {
                    name: 'standalone',
                    message: 'Standalone:                 Nx creates a single project and makes it fast.',
                },
            ],
        },
    ]);
    invariant(workspaceType, {
        title: 'Invalid workspace type',
        bodyLines: [
            `It must be one of the following: standalone, integrated. Got ${workspaceType}`,
        ],
    });
    return workspaceType;
}
async function determineStandaloneOrMonorepo() {
    const { workspaceType } = await enquirer.prompt([
        {
            type: 'autocomplete',
            name: 'workspaceType',
            message: `Integrated monorepo, or standalone project?`,
            initial: 1,
            choices: [
                {
                    name: 'integrated',
                    message: 'Integrated Monorepo:  Nx creates a monorepo that contains multiple projects.',
                },
                {
                    name: 'standalone',
                    message: 'Standalone:           Nx creates a single project and makes it fast.',
                },
            ],
        },
    ]);
    invariant(workspaceType, {
        title: 'Invalid workspace type',
        bodyLines: [
            `It must be one of the following: standalone, integrated. Got ${workspaceType}`,
        ],
    });
    return workspaceType;
}
async function determineAppName(parsedArgs) {
    if (parsedArgs.appName)
        return parsedArgs.appName;
    const { appName } = await enquirer.prompt([
        {
            name: 'appName',
            message: `Application name`,
            type: 'input',
            initial: parsedArgs.name,
        },
    ]);
    invariant(appName, {
        title: 'Invalid name',
        bodyLines: [`Name cannot be empty`],
    });
    return appName;
}
async function determineReactFramework(parsedArgs) {
    const reply = await enquirer.prompt([
        {
            name: 'framework',
            message: 'What framework would you like to use?',
            type: 'autocomplete',
            choices: [
                {
                    name: 'none',
                    message: 'None',
                    hint: '         I only want react and react-dom',
                },
                {
                    name: 'nextjs',
                    message: 'Next.js       [ https://nextjs.org/      ]',
                },
                {
                    name: 'remix',
                    message: 'Remix         [ https://remix.run/       ]',
                },
                {
                    name: 'expo',
                    message: 'Expo          [ https://expo.io/         ]',
                },
                {
                    name: 'react-native',
                    message: 'React Native  [ https://reactnative.dev/ ]',
                },
            ],
            initial: 0,
        },
    ]);
    return reply.framework;
}
async function determineReactBundler(parsedArgs) {
    if (parsedArgs.bundler)
        return parsedArgs.bundler;
    const reply = await enquirer.prompt([
        {
            name: 'bundler',
            message: `Which bundler would you like to use?`,
            type: 'autocomplete',
            choices: [
                {
                    name: 'vite',
                    message: 'Vite    [ https://vitejs.dev/     ]',
                },
                {
                    name: 'webpack',
                    message: 'Webpack [ https://webpack.js.org/ ]',
                },
                {
                    name: 'rspack',
                    message: 'Rspack  [ https://www.rspack.dev/ ]',
                },
            ],
        },
    ]);
    return reply.bundler;
}
async function determineNextAppDir(parsedArgs) {
    if (parsedArgs.nextAppDir !== undefined)
        return parsedArgs.nextAppDir;
    const reply = await enquirer.prompt([
        {
            name: 'nextAppDir',
            message: 'Would you like to use the App Router (recommended)?',
            type: 'autocomplete',
            choices: [
                {
                    name: 'Yes',
                },
                {
                    name: 'No',
                },
            ],
            initial: 0,
        },
    ]);
    return reply.nextAppDir === 'Yes';
}
async function determineNextSrcDir(parsedArgs) {
    if (parsedArgs.nextSrcDir !== undefined)
        return parsedArgs.nextSrcDir;
    const reply = await enquirer.prompt([
        {
            name: 'nextSrcDir',
            message: 'Would you like to use the src/ directory?',
            type: 'autocomplete',
            choices: [
                {
                    name: 'Yes',
                },
                {
                    name: 'No',
                },
            ],
            initial: 0,
        },
    ]);
    return reply.nextSrcDir === 'Yes';
}
async function determineVueFramework(parsedArgs) {
    if (!!parsedArgs.framework)
        return parsedArgs.framework;
    const reply = await enquirer.prompt([
        {
            name: 'framework',
            message: 'What framework would you like to use?',
            type: 'autocomplete',
            choices: [
                {
                    name: 'none',
                    message: 'None',
                    hint: '         I only want Vue',
                },
                {
                    name: 'nuxt',
                    message: 'Nuxt          [ https://nuxt.com/ ]',
                },
            ],
            initial: 0,
        },
    ]);
    return reply.framework;
}
async function determineNodeFramework(parsedArgs) {
    if (parsedArgs.framework)
        return parsedArgs.framework;
    const reply = await enquirer.prompt([
        {
            message: 'What framework should be used?',
            type: 'autocomplete',
            name: 'framework',
            choices: [
                {
                    name: 'none',
                    message: 'None',
                },
                {
                    name: 'express',
                    message: 'Express [ https://expressjs.com/ ]',
                },
                {
                    name: 'fastify',
                    message: 'Fastify [ https://www.fastify.dev/ ]',
                },
                {
                    name: 'koa',
                    message: 'Koa     [ https://koajs.com/      ]',
                },
                {
                    name: 'nest',
                    message: 'NestJs  [ https://nestjs.com/     ]',
                },
            ],
        },
    ]);
    return reply.framework;
}
async function determineE2eTestRunner(parsedArgs) {
    if (parsedArgs.e2eTestRunner)
        return parsedArgs.e2eTestRunner;
    const reply = await enquirer.prompt([
        {
            message: 'Test runner to use for end to end (E2E) tests',
            type: 'autocomplete',
            name: 'e2eTestRunner',
            choices: [
                {
                    name: 'playwright',
                    message: 'Playwright [ https://playwright.dev/ ]',
                },
                {
                    name: 'cypress',
                    message: 'Cypress [ https://www.cypress.io/ ]',
                },
                {
                    name: 'none',
                    message: 'None',
                },
            ],
        },
    ]);
    return reply.e2eTestRunner;
}
